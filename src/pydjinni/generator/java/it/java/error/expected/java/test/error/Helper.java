// AUTOGENERATED FILE - DO NOT MODIFY!
// This file was generated by PyDjinni from 'error.pydjinni'
package test.error;

public abstract class Helper {
    static {
        test.error.pydjinni.NativeErrorTestJniLoader.loadLibrary();
    }
    /**
     * @throws test.error.FooError when something goes wrong
     * @throws test.error.BarError when something else goes wrong
     */
    public static void throwingError() throws FooError, BarError {
        CppProxy.throwingError();
    };
    public static void throwingWithParameters() throws FooError {
        CppProxy.throwingWithParameters();
    };
    public static java.util.concurrent.CompletableFuture<Void> throwingAsync() {
        return CppProxy.throwingAsync();
    };
    public static java.util.concurrent.CompletableFuture<Boolean> throwingAsyncWithReturnValue() {
        return CppProxy.throwingAsyncWithReturnValue();
    };
    public static void throwingCallbackError(test.error.ThrowingCallback callback) throws FooError {
        CppProxy.throwingCallbackError(callback);
    };
    public static java.util.concurrent.CompletableFuture<Void> throwingAsyncCallbackError(test.error.AsyncThrowingCallback callback) {
        return CppProxy.throwingAsyncCallbackError(callback);
    };
    public abstract void nonstaticThrowingError() throws FooError;
    private static final class CppProxy extends Helper {
        private final long nativeRef;

        static class CleanupTask implements Runnable {
            private final long nativeRef;
            CleanupTask(long nativeRef) {
                this.nativeRef = nativeRef;
            }

            @Override
            public void run() {
                nativeDestroy(this.nativeRef);
            }

            private native void nativeDestroy(long nativeRef);
        }

        private CppProxy(long nativeRef) {
            if (nativeRef == 0) throw new RuntimeException("nativeRef is zero");
            this.nativeRef = nativeRef;
            test.error.pydjinni.NativeCleaner.register(this, new CleanupTask(nativeRef));
        }

        public static native void throwingError();
        public static native void throwingWithParameters();
        public static native java.util.concurrent.CompletableFuture<Void> throwingAsync();
        public static native java.util.concurrent.CompletableFuture<Boolean> throwingAsyncWithReturnValue();
        public static native void throwingCallbackError(test.error.ThrowingCallback callback);
        public static native java.util.concurrent.CompletableFuture<Void> throwingAsyncCallbackError(test.error.AsyncThrowingCallback callback);
        @Override
        public void nonstaticThrowingError() {
            native_nonstaticThrowingError(this.nativeRef );
        }
        private native void native_nonstaticThrowingError(long _nativeRef);
    }
}
